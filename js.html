<script>
    /**
     * Global State
     */
    let PRODUCT_CATALOG = [];
    let CURRENT_CLIENT = null;
    const CLIENT_ID = window.initialClientId; // Defined in index.html

    /**
     * Helper: Convert string to safe CSS Class
     */
    function toCssClass(str) {
        if (!str) return 'cat-unknown';
        return 'cat-' + str.toLowerCase()
            .replace(/[^a-z0-9]/g, '-') // Replace non-alphanumeric with hyphen
            .replace(/-+/g, '-')        // Collapse multiple hyphens
            .replace(/^-|-$/g, '');     // Trim hyphens
    }

    /**
     * Helper: Escape Regex Characters
     */
    function escapeRegex(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    /**
     * Helper: Calculate Contrast Color (Black or White) from Hex
     */
    function getContrastYIQ(hexcolor) {
        hexcolor = hexcolor.replace("#", "");
        var r = parseInt(hexcolor.substr(0, 2), 16);
        var g = parseInt(hexcolor.substr(2, 2), 16);
        var b = parseInt(hexcolor.substr(4, 2), 16);
        var yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
        // Reverted to 190 per user request to prefer White text
        return (yiq >= 190) ? 'black' : 'white';
    }



    /**
     * Initialize
     */
    window.onload = function () {
        console.log("Window loaded");

        if (!CLIENT_ID) {
            // No ID in URL -> Show Login View
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('login-view').classList.remove('hidden');
            return;
        }

        // DEBUG: Alert to confirm we are starting
        // alert("App Loaded. Client ID: " + CLIENT_ID); 

        document.getElementById('header-total').classList.remove('hidden'); // Show Subtotal

        // Scroll Shadow for App Bar
        window.addEventListener('scroll', () => {
            const appBar = document.querySelector('.md3-top-app-bar');
            if (window.scrollY > 0) {
                appBar.classList.add('scrolled-header');
            } else {
                appBar.classList.remove('scrolled-header');
            }
        });

        // 1. Apply Main Color if exists
        if (window.categorySettings && window.categorySettings['Main']) {
            const mainColor = window.categorySettings['Main'];
            document.documentElement.style.setProperty('--md-sys-color-primary', mainColor);
            // Also apply to App Bar directly to be safe
            const appBar = document.querySelector('.md3-top-app-bar');
            if (appBar) appBar.style.backgroundColor = mainColor;
        }

        // 2. Fetch Client Data
        fetchClientData(CLIENT_ID);
    };

    /**
     * Handle Manual Login
     */
    function handleManualLogin() {
        const input = document.getElementById('manual-client-id');
        const id = input.value.trim();

        if (!id) {
            showLoginError("Please enter a Client ID.");
            return;
        }

        // Hide Login, Show Loading
        document.getElementById('login-view').classList.add('hidden');
        document.getElementById('loading').classList.remove('hidden');

        // Update Global and Fetch
        // We act as if it came from URL
        fetchClientData(id);
    }

    function showLoginError(msg) {
        const el = document.getElementById('login-error-msg');
        el.textContent = msg;
        el.classList.remove('hidden');
        document.getElementById('manual-client-id').classList.add('error-state'); // Optional: shake or red border
    }

    function clearLoginError() {
        document.getElementById('login-error-msg').classList.add('hidden');
    }

    function fetchClientData(id) {
        google.script.run
            .withSuccessHandler(onClientDataSuccess)
            .withFailureHandler(onLoginFailure)
            .getClientById(id);
    }

    function onLoginFailure(error) {
        // If specific login fail
        showError("Invalid Client ID or System Error.");

        // DEBUG: Fetch and show debug info to help user
        const input = document.getElementById('manual-client-id');
        const id = input ? input.value : (CLIENT_ID || "Unknown");

        google.script.run
            .withSuccessHandler(info => {
                const msg = `DEBUG RAW DATA:\nSheet: ${info.sheetName}\nTotal Rows: ${info.totalSheetRows}\nRaw Headers (Row 1): ${info.rawHeaders}\nFirst Data (Row 2): ${info.rawFirstRowData}\nParsed Keys: ${info.parsedObjectKeys}`;
                alert(msg);
            })
            .debugClientLookup(id);

        document.getElementById('error').innerHTML += `<br><button class="md3-btn-filled" onclick="location.reload()">Try Again</button>`;
    }

    function onClientDataSuccess(client) {
        // alert("Client Data Success: " + (client ? client.Name : "null"));
        if (!client) {
            showError("Client not found in database.");
            return;
        }

        CURRENT_CLIENT = client;
        document.getElementById('client-name-input').value = client['Name'] || "";
        document.getElementById('client-address-input').value = client['Address'] || "";

        // 2. Fetch Products
        // alert("Fetching Products...");
        google.script.run
            .withSuccessHandler(onProductsSuccess)
            .withFailureHandler(onFailure)
            .getProductCatalog();
    }

    function onProductsSuccess(products) {
        PRODUCT_CATALOG = products;

        try {
            renderProducts(products);
        } catch (e) {
            console.error("Render Error:", e);
            alert("Error rendering products: " + e.message);
        }

        document.getElementById('loading').classList.add('hidden');
        document.getElementById('order-form').classList.remove('hidden');
        document.getElementById('collapse-fab').classList.remove('hidden'); // Show FAB
    }

    /**
     * Collapse All Categories
     */
    function collapseAllCats() {
        const details = document.querySelectorAll('details');
        details.forEach(d => d.open = false);
    }

    /**
     * Render Product List
     */
    /**
     * Render Product List grouped by Category
     */
    /**
     * Render Product List grouped by Category
     * Supports:
     * 1. Matrix Groups (e.g. SODA SQ)
     * 2. Compact Tables (Standard items)
     */
    function renderProducts(products) {
        const container = document.getElementById('product-list');
        container.innerHTML = "";

        // --- DYNAMIC STYLE GENERATION (User Request: Class Based) ---
        // Create a style block for category colors
        const styleId = 'dynamic-cat-syles';
        let styleBlock = document.getElementById(styleId);
        if (!styleBlock) {
            styleBlock = document.createElement('style');
            styleBlock.id = styleId;
            document.head.appendChild(styleBlock);
        }

        let cssRules = "";
        if (window.categorySettings) {
            Object.keys(window.categorySettings).forEach(cat => {
                const setting = window.categorySettings[cat];
                const color = (typeof setting === 'object' && setting.color) ? setting.color : (typeof setting === 'string' ? setting : null);

                const cleanClass = toCssClass(cat);
                if (cleanClass && color) {
                    const textColor = getContrastYIQ(color);
                    // 1. Apply Color to Category Header ONLY when OPEN
                    cssRules += `.${cleanClass}[open] > .category-summary { background-color: ${color} !important; color: ${textColor} !important; }\n`;
                    // 2. Add Top Radius when Expanded (or always, as requested for "top of them")
                    cssRules += `.${cleanClass}[open] > .category-summary { border-top-left-radius: 12px; border-top-right-radius: 12px; border-bottom-left-radius: 0; border-bottom-right-radius: 0; }\n`;
                    // 3. Round bottom if closed
                    cssRules += `.${cleanClass}:not([open]) > .category-summary { border-radius: 12px; transition: border-radius 0.2s ease; }\n`;

                    // Matrix Header Background (if used)
                    cssRules += `.${cleanClass} .matrix-header-row { background-color: ${color} !important; color: ${textColor} !important; }\n`;

                    // Set variable for generic usage
                    cssRules += `.${cleanClass} { --category-color: ${color}; }\n`;
                }
            });
        }
        console.log("DEBUG: Generated CSS Rules:", cssRules);
        styleBlock.textContent = cssRules;

        // 0. Normalize Data
        const normalizedProducts = products.map(p => {
            let name = String(p.name).trim();
            let varName = String(p.variation || "").trim();
            const nameIsSize = /^\d+(\.\d+)?\s*([a-zA-Z%]+)?$/.test(name);
            const varIsName = varName && /[a-zA-Z]/.test(varName) && varName.length > 2;

            if (nameIsSize && varIsName) {
                return { ...p, name: varName, variation: name };
            }
            return p;
        });

        // 1. Group by Category
        const groupedByCat = {};
        normalizedProducts.forEach(p => {
            const cat = p.category || "Uncategorized";
            if (!groupedByCat[cat]) groupedByCat[cat] = [];
            groupedByCat[cat].push(p);
        });

        // SORTING LOGIC: Respect Numeric Order from Settings (Col H)
        let categories = Object.keys(groupedByCat);

        categories.sort((a, b) => {
            const setA = window.categorySettings && window.categorySettings[a];
            const setB = window.categorySettings && window.categorySettings[b];

            // Default to 999 if no order set
            const orderA = (setA && typeof setA.order === 'number') ? setA.order : 999;
            const orderB = (setB && typeof setB.order === 'number') ? setB.order : 999;

            if (orderA !== orderB) {
                return orderA - orderB;
            }

            // Tie-break: Alphabetical
            return a.localeCompare(b);
        });

        categories.forEach(cat => {
            const catDetails = document.createElement('details');
            catDetails.open = false; // Default closed
            // Add dynamic class to Top Level Category Header
            const catClass = toCssClass(cat);
            catDetails.className = `category-details ${catClass}`;

            const catSummary = document.createElement('summary');
            catSummary.className = "md3-headline-medium category-summary";
            // Use innerHTML to add Subtotal Span
            catSummary.innerHTML = `
                <span style="flex:1;">${cat}</span>
                <span class="cat-subtotal" style="font-size:0.8em; opacity:0.9; margin-left:12px; font-weight:bold; display:none;">$0.00</span>
            `;
            // Ensure Flex display for spacing
            catSummary.style.display = "flex";
            catSummary.style.justifyContent = "space-between";
            catSummary.style.alignItems = "center";
            catDetails.appendChild(catSummary);

            const catContent = document.createElement('div');
            catContent.className = "category-content";

            const groups = groupProductsDynamically(groupedByCat[cat]);
            const sortedGroupNames = Object.keys(groups).sort();

            sortedGroupNames.forEach(baseName => {
                const group = groups[baseName];
                const isMatrix = checkMatrixEligibility(group);

                // --- BUILD DYNAMIC HEADER COLUMNS ---
                let headerColsHtml = "";
                let colDefs = [];

                if (isMatrix) {
                    // ... (Matrix logic unchanged) ...
                    const allNames = [...new Set(group.map(p => p.name))].sort((a, b) => {
                        const numA = parseInt(a.replace(/\D/g, '')) || 0;
                        const numB = parseInt(b.replace(/\D/g, '')) || 0;
                        return numA - numB;
                    });
                    colDefs = allNames.map(name => {
                        const regex = new RegExp("^" + escapeRegex(baseName), "i");
                        let label = name.replace(regex, "").trim();
                        label = label.replace(/^[\s\-\&]+/, "").trim(); // Clean prefix
                        if (!label) label = "Std";
                        const p = group.find(prod => prod.name === name);
                        const price = p ? Number(p.price).toFixed(2) : "0.00";
                        return { label: label, price: price, name: name };
                    });
                } else {
                    // Standard / Compact Logic
                    // Check for Case existence and common units
                    const caseProducts = group.filter(p => (parseInt(p.unitsPerCase) || 1) > 1);
                    const showCase = caseProducts.length > 0;

                    let caseHeaderLabel = "Case";
                    // Check if all cases have same size
                    if (showCase) {
                        const firstSize = parseInt(caseProducts[0].unitsPerCase) || 1;
                        const allSame = caseProducts.every(p => (parseInt(p.unitsPerCase) || 1) === firstSize);
                        if (allSame) {
                            caseHeaderLabel += ` <br><span style="font-size:10px; opacity:0.8;">(Box ${firstSize})</span>`;
                        }
                    }

                    headerColsHtml += `<div class="col-data"><span>Qty</span></div>`;
                    headerColsHtml += `<div class="col-data"><span>Price</span></div>`;
                    if (showCase) headerColsHtml += `<div class="col-data"><span>${caseHeaderLabel}</span></div>`;
                }

                // Determine Sticky
                const isSticky = group.length > 2;

                const prodDetails = document.createElement('details');
                prodDetails.open = false; // Default closed

                // ASSIGN DYNAMIC CATEGORY CLASS
                const catClass = toCssClass(cat);
                prodDetails.className = `product-group-details mb-3 ${catClass}`;
                prodDetails.ontoggle = (e) => handleToggle(e, prodDetails);

                const prodSummary = document.createElement('summary');
                prodSummary.className = "product-group-header";
                if (!isSticky) prodSummary.classList.add('no-sticky');

                // MAIN FLEX HEADER
                // Determine Header Color
                // 1. Try first product in group for specific override
                const leader = group[0];
                const headerColor = leader.backgroundColor ? leader.backgroundColor : "";
                const headerTextColor = leader.textColor ? leader.textColor : "";

                // Color Logic: Use only when expanded
                const groupClass = 'prod-' + escapeRegex(baseName).replace(/[^a-zA-Z0-9-]/g, '-').toLowerCase();
                prodDetails.classList.add(groupClass);

                if (headerColor) {
                    const dynamicStyle = document.getElementById('dynamic-cat-syles');
                    if (dynamicStyle) {
                        // Apply color ONLY when open, with Contrast Text or Explicit Text Color
                        // Target PARENT summary for proper full-width background
                        const textColor = headerTextColor ? headerTextColor : getContrastYIQ(headerColor);
                        dynamicStyle.textContent += `.${groupClass}[open] > summary { background-color: ${headerColor} !important; }\n`;
                        dynamicStyle.textContent += `.${groupClass}[open] > summary .header-content { background-color: transparent !important; color: ${textColor} !important; }\n`;
                        dynamicStyle.textContent += `.${groupClass}[open] > summary .header-content a { color: ${textColor} !important; }\n`;
                    }
                }

                prodSummary.innerHTML = `
                    <div class="header-content grid-header-row">
                        <span class="prod-title col-name">
                            ${baseName}
                            ${(leader.image || leader.description) ?
                        `<a href="#" onclick="showDetails(event, '${leader.name}', '${(leader.description || "").replace(/'/g, "\\'")}', '${(leader.image || "").replace(/'/g, "\\'")}', '${Number(leader.salePrice || 0)}', '${Number(leader.price || 0)}')" 
                                   style="font-size:11px; margin-left:8px; color:inherit; text-decoration:underline; opacity:0.9;">Details</a>`
                        : ""}
                        </span>
                        
                        <!-- Subtotal Span -->
                        <span class="prod-subtotal" style="font-size:0.9em; font-weight:bold; margin-right: 12px; display:none;">$0.00</span>
                        
                        <div class="header-expanded-content">
                            ${headerColsHtml}
                        </div>
                    </div>`;

                prodDetails.appendChild(prodSummary);

                const prodContent = document.createElement('div');
                prodContent.className = "product-content details-animation-wrapper"; // Added wrapper class

                if (isMatrix) {
                    prodContent.innerHTML = renderMatrixGroupFlex(baseName, group, colDefs);
                } else {
                    prodContent.innerHTML = renderCompactTableFlex(baseName, group);
                }

                prodDetails.appendChild(prodContent);
                catContent.appendChild(prodDetails);
            });

            // Wrap category content as well for animation
            const catWrapper = document.createElement('div');
            catWrapper.className = "details-animation-wrapper";
            catWrapper.appendChild(catContent);

            catDetails.appendChild(catWrapper);
            container.appendChild(catDetails);
        });

        attachInputListeners();
        setupStickyObservers();

        // Initialize Accordion Animation Logic
        initAccordionAnimation();
    }

    // --- ACCORDION ANIMATION HELPER ---
    function initAccordionAnimation() {
        // Remove existing listener if any (benign to re-add if careful, but best to be safe)
        // Since this runs on render, checking a global flag or delegate
        if (window._accordionInitialized) return;
        window._accordionInitialized = true;

        document.addEventListener('click', function (e) {
            const summary = e.target.closest('summary');
            if (!summary) return;

            const details = summary.parentElement;
            if (!details) return;

            // Check if it's one of our animated details
            // Look for the wrapper child
            const wrapper = details.querySelector('.details-animation-wrapper');
            if (!wrapper) return;

            e.preventDefault(); // Prevent default browser toggle

            if (details.open) {
                // CLOSE ANIMATION
                // 1. Set explicit height to current scrollHeight (transition start point)
                const startHeight = wrapper.offsetHeight;

                // IMPORTANT: Set overflow hidden to allow height animation
                wrapper.style.overflow = 'hidden';

                wrapper.style.height = startHeight + 'px';

                // Force Reflow
                wrapper.offsetHeight;

                // 2. Set to 0
                wrapper.style.height = '0px';

                // 3. Remove open attribute after transition
                // Use a one-time listener
                wrapper.addEventListener('transitionend', function onEnd() {
                    wrapper.removeEventListener('transitionend', onEnd);
                    if (wrapper.style.height === '0px') { // Check we didn't interrupt
                        details.open = false;
                        wrapper.style.height = ''; // Clean up
                    }
                });

            } else {
                // OPEN ANIMATION
                // 1. Add open attribute
                details.open = true;

                // 2. Get target height
                // Temporarily unrestrict height to measure
                wrapper.style.height = 'auto';
                const targetHeight = wrapper.scrollHeight;

                // 3. Set start height to 0
                wrapper.style.height = '0px';

                // Force Reflow
                wrapper.offsetHeight;

                // 4. Animate to target
                wrapper.style.height = targetHeight + 'px';

                // 5. Clean up after transition
                wrapper.addEventListener('transitionend', function onEnd() {
                    wrapper.removeEventListener('transitionend', onEnd);
                    if (wrapper.style.height !== '0px') {
                        wrapper.style.height = 'auto'; // allow dynamic content growth
                        // RESTORE STICKY: Allow overflow so sticky descendants work
                        wrapper.style.overflow = 'visible';
                    }
                });
            }
        });
    }

    // --- FLEX RENDER FUNCTIONS ---

    // --- DETAILS BUBBLE LOGIC ---
    // --- DETAILS BUBBLE LOGIC ---
    function showDetails(event, name, desc, img, salePrice, regPrice) {
        if (event) event.stopPropagation();

        const overlay = document.getElementById('bubble-overlay');
        const bubble = document.getElementById('details-bubble');
        const titleEl = document.getElementById('bubble-title');
        const descEl = document.getElementById('bubble-desc');
        const imgContainer = document.getElementById('bubble-img-container');

        titleEl.textContent = name;

        // Price Logic in Bubble
        let priceHtml = "";
        const sPrice = Number(salePrice);
        const rPrice = Number(regPrice);

        if (sPrice > 0) {
            priceHtml = `<div style="margin-bottom:8px;">
                            <span style="text-decoration:line-through; color:#999; margin-right:8px;">$${rPrice.toFixed(2)}</span>
                            <span style="color:#D32F2F; font-weight:bold; font-size:1.1em;">$${sPrice.toFixed(2)}</span>
                         </div>`;
        } else {
            priceHtml = `<div style="margin-bottom:8px; font-weight:bold;">$${rPrice.toFixed(2)}</div>`;
        }

        descEl.innerHTML = priceHtml + (desc || "No description available.");

        imgContainer.innerHTML = "";
        if (img) {
            const image = document.createElement('img');
            image.src = img;
            image.className = "details-img";
            image.onerror = function () { this.style.display = 'none'; imgContainer.innerHTML = '<span style="color:#aaa">Image failed to load</span>'; };
            imgContainer.appendChild(image);
            imgContainer.style.display = 'flex';
        } else {
            imgContainer.style.display = 'none';
        }

        overlay.style.display = 'block';
        bubble.style.display = 'block';
    }

    function closeDetails() {
        document.getElementById('bubble-overlay').style.display = 'none';
        document.getElementById('details-bubble').style.display = 'none';
    }

    // --- FLEX RENDER FUNCTIONS ---

    function renderMatrixGroupFlex(title, products, colDefs) {
        const rowLabels = [...new Set(products.map(p => p.variation || "Standard"))].sort();

        // Add 'matrix-scroll-view' class for CSS targeting
        let html = `<div class="table-container matrix-scroll-view">`;

        // 1. Internal Header Row (Scrolls with content, Sticks to top)
        html += `<div class="grid-header-row matrix-header-row" style="display:flex; width:max-content; min-width:100%;">`;
        html += `<div class="col-name matrix-name-col" style="flex:0 0 160px; min-width:160px; position:sticky; left:0; background:inherit; z-index:2; border-right:1px solid rgba(0,0,0,0.1);">${title}</div>`;
        colDefs.forEach(col => {
            html += `<div class="col-data" style="flex:0 0 90px; width:90px; min-width:90px; justify-content:center;">
                        <span style="font-size:13px; font-weight:bold; display:block; text-align:center; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; width:100%;" title="${col.label}">${col.label}</span>
                      </div>`;
        });
        html += `</div>`;

        // 2. Data Rows
        rowLabels.forEach(rowName => {
            html += `<div class="grid-data-row" style="display:flex; width:max-content; min-width:100%;">`;
            html += `<div class="col-name matrix-name-col" style="flex:0 0 160px; min-width:160px; position:sticky; left:0; background:var(--md-sys-color-surface); z-index:1; border-right:1px solid #eee;">${rowName}</div>`;

            colDefs.forEach(col => {
                const product = products.find(p =>
                    (p.variation === rowName || (!p.variation && rowName === "Standard")) &&
                    p.name === col.name
                );

                html += `<div class="col-data" style="flex:0 0 90px; width:90px; min-width:90px; justify-content:center;">`;
                if (product) {
                    // Logic for Sales
                    // Check Category Sale Active Status
                    const catSetting = window.categorySettings && window.categorySettings[product.category];
                    const catSaleActive = catSetting ? catSetting.saleActive : false;

                    const isSale = catSaleActive && product.onSale && (product.salePrice > 0);

                    html += `
                        <input type="number"
                               inputmode="numeric"
                               pattern="[0-9]*"
                               min="0"
                               data-sku="${product.sku}"
                               data-type="unit"
                               data-category="${product.category}"
                               data-group="${escapeRegex(title)}"
                               class="table-input qty-input"
                               placeholder="0">`;

                    // Add Price hint if Sale
                    if (isSale) {
                        html += `<div style="font-size:10px; color:red; font-weight:bold;">$${Number(product.salePrice).toFixed(2)}</div>`;
                    }

                } else {
                    html += `- `;
                }
                html += `</div>`;
            });
            html += `</div>`;
        });

        html += `</div>`;
        return html;
    }

    function renderCompactTableFlex(title, products) {
        // 1. Group by Variation to merge Single + Case
        const merged = {};
        const orderedKeys = []; // Keep track of insertion order for Sheet Sort

        products.forEach(p => {
            let label = p.variation;
            if (!label || label === "Standard") {
                // Regex: Match Base Name at START of string only
                const regex = new RegExp("^" + escapeRegex(title), "i");
                if (title && p.name) {
                    label = p.name.replace(regex, "").trim();
                    // Remove leading special chars that might remain (like " - " or " & ")
                    label = label.replace(/^[\s\-\&]+/, "").trim();
                }
            }
            if (!label) label = "Standard"; // Fallback

            // Normalize label key
            const key = label.toLowerCase();

            // If new key, add to ordered list
            if (!merged[key]) {
                merged[key] = { label: label, single: null, case: null };
                orderedKeys.push(key);
            }

            // Heuristic: If unitsPerCase > 1, it's a case
            const units = parseInt(p.unitsPerCase) || 1;
            if (units > 1) {
                merged[key].case = p;
            } else {
                merged[key].single = p;
            }
        });

        // Use VALIDATED SHEET ORDER (No alphabetic sort)
        const rows = orderedKeys.map(k => merged[k]);

        // Determine if we need the "Case" column at all for this group
        const hasAnyCase = rows.some(r => r.case !== null);

        let html = `<div class="table-container">`;

        rows.forEach(r => {
            const pSingle = r.single;
            const pCase = r.case;
            // Use single as leader for badges/info, fallback to case
            const leader = pSingle || pCase;

            // Sales Logic (Leader)
            const catSetting = window.categorySettings && window.categorySettings[leader.category];
            const catSaleActive = catSetting ? catSetting.saleActive : false;
            const isSale = catSaleActive && leader.onSale && (leader.salePrice > 0);

            // Info Icon
            let infoHtml = "";
            if (leader.description || leader.image) {
                const cleanName = (leader.name + " " + (leader.variation || "")).replace(/"/g, "&quot;");
                const cleanDesc = (leader.description || "").replace(/"/g, "&quot;");
                const cleanImg = (leader.image || "").replace(/"/g, "&quot;");
                const sPrice = Number(leader.salePrice) || 0;
                const rPrice = Number(leader.price) || 0;
                infoHtml = `<span class="info-icon" onclick="showDetails(event, '${cleanName}', '${cleanDesc}', '${cleanImg}', '${sPrice}', '${rPrice}')">i</span>`;
            }

            html += `<div class="grid-data-row">`;
            html += `<div class="col-name">
                        ${r.label} 
                        ${isSale ? '<span class="sale-badge">SALE</span>' : ''}
                        ${infoHtml}
                     </div>`;

            // --- SINGLE COLUMN ---
            html += `<div class="col-data">`;
            if (pSingle) {
                const isSingleSale = catSaleActive && pSingle.onSale && (pSingle.salePrice > 0);
                const displayPrice = isSingleSale ? pSingle.salePrice : pSingle.price;
                const priceClass = isSingleSale ? "sale-price-highlight" : "";

                html += `<input type="number" inputmode="numeric" pattern="[0-9]*" min="0"
                    data-sku="${pSingle.sku}" data-type="unit"
                    data-category="${leader.category}" data-group="${escapeRegex(title)}"
                    class="table-input qty-input" placeholder="0">`;

                // ALWAYS Show Price
                html += `<div class="price-sub ${priceClass}">$${Number(displayPrice).toFixed(2)}</div>`;
                if (isSingleSale) {
                    html += `<div class="price-sub original-price-strikethrough" style="font-size:9px;">$${Number(pSingle.price).toFixed(2)}</div>`;
                }
            }
            html += `</div>`;

            // --- CASE COLUMN ---
            if (hasAnyCase) {
                html += `<div class="col-data">`;
                if (pCase) {
                    const units = parseInt(pCase.unitsPerCase);
                    // Check if Case itself is on sale (usually inherits status, but check attributes)
                    const isCaseSale = catSaleActive && pCase.onSale && (pCase.salePrice > 0);
                    const casePrice = isCaseSale ? pCase.salePrice : pCase.price;
                    const cPriceClass = isCaseSale ? "sale-price-highlight" : "";

                    html += `<input type="number" inputmode="numeric" pattern="[0-9]*" min="0"
                    data-sku="${pCase.sku}" data-type="case" data-per-case="${units}"
                    data-category="${leader.category}" data-group="${escapeRegex(title)}"
                    class="table-input qty-input" placeholder="0">`;

                    // ALWAYS Show Price
                    html += `<div class="price-sub ${cPriceClass}">$${Number(casePrice).toFixed(2)}</div>`;
                    if (isCaseSale) {
                        html += `<div class="price-sub original-price-strikethrough" style="font-size:9px;">$${Number(pCase.price).toFixed(2)}</div>`;
                    }
                } else {
                    html += `<span style="color:#ccc;">-</span>`;
                }
                html += `</div > `;
            }

            html += `</div > `;
        });

        html += `</div>`;
        return html;
    }

    function attachInputListeners() {
        const inputs = document.querySelectorAll('.qty-input');
        inputs.forEach(input => {
            input.removeEventListener('input', calculateTotal); // Safety
            input.addEventListener('input', calculateTotal);
        });
    }

    /**
     * Calculate Totals
     */
    function calculateTotal() {
        let totalPieces = 0;
        let grandTotal = 0;

        // Maps to store element totals
        const catTotals = new Map();
        const prodTotals = new Map();

        const inputs = document.querySelectorAll('.qty-input');

        // Reset Spans first (Visual reset)
        // We will only show them if > 0 later
        document.querySelectorAll('.cat-subtotal, .prod-subtotal').forEach(el => {
            el.style.display = 'none';
        });

        inputs.forEach(input => {
            const val = parseInt(input.value) || 0;
            if (val > 0) {
                // Find product in catalog
                const sku = input.dataset.sku;
                const product = PRODUCT_CATALOG.find(p => p.sku === sku);

                if (product) {
                    const price = Number(product.price) || 0;
                    const salePrice = Number(product.salePrice) || 0;

                    // Check Category Sale Active Status
                    const catSetting = window.categorySettings && window.categorySettings[product.category];
                    const catSaleActive = catSetting ? catSetting.saleActive : false;

                    const isOnSale = catSaleActive && product.onSale && salePrice > 0;
                    const finalPrice = isOnSale ? salePrice : price;

                    let lineTotal = 0;
                    if (input.dataset.type === 'case') {
                        const perCase = parseInt(input.dataset.perCase) || 1;
                        totalPieces += (val * perCase);
                        lineTotal = (finalPrice * val);
                    } else {
                        // Unit
                        totalPieces += val;
                        lineTotal = (finalPrice * val);
                    }
                    grandTotal += lineTotal;

                    // Aggregate for Headers
                    const pDetails = input.closest('.product-group-details');
                    const cDetails = input.closest('.category-details');

                    if (pDetails) {
                        prodTotals.set(pDetails, (prodTotals.get(pDetails) || 0) + lineTotal);
                    }
                    if (cDetails) {
                        catTotals.set(cDetails, (catTotals.get(cDetails) || 0) + lineTotal);
                    }
                }
            }
        });

        document.getElementById('total-pieces').textContent = totalPieces;
        document.getElementById('header-total').textContent = `Total: $${grandTotal.toFixed(2)} `;

        // Update UI Spans
        for (const [el, total] of catTotals.entries()) {
            const span = el.querySelector('.category-summary .cat-subtotal');
            if (span && total > 0) {
                span.textContent = `$${total.toFixed(2)} `;
                span.style.display = 'block';
            }
        }

        for (const [el, total] of prodTotals.entries()) {
            // prodSummary is the first child summary
            const summary = el.querySelector('summary');
            if (summary) {
                const span = summary.querySelector('.prod-subtotal');
                if (span && total > 0) {
                    span.textContent = `$${total.toFixed(2)}`;
                    span.style.display = 'block';
                }
            }
        }
    }

    /**
     * Submit Order
     */
    /**
     * REVIEW & SUBMIT LOGIC
     */
    let lastItems = []; // Store for Summary and Submission

    function gatherItems() {
        const inputs = document.querySelectorAll('.qty-input');
        const itemsMap = {}; // Map sku to total qty

        // Aggregate quantities by SKU
        inputs.forEach(input => {
            const val = parseInt(input.value) || 0;
            if (val > 0) {
                const sku = input.dataset.sku;
                if (!itemsMap[sku]) itemsMap[sku] = 0;

                if (input.dataset.type === 'case') {
                    // Do not multiply by perCase for the payload if the SKU is specific to the Case
                    itemsMap[sku] += val;
                } else {
                    itemsMap[sku] += val;
                }
            }
        });

        const items = Object.keys(itemsMap).map(sku => ({
            sku: sku,
            quantity: itemsMap[sku] // Total units
        }));

        return items;
    }

    function reviewOrder() {
        const items = gatherItems();

        if (items.length === 0) {
            alert("Please add at least one item.");
            return;
        }

        lastItems = items; // Save global state

        // Generate HTML
        const tableHtml = generateOrderSummaryHtml(items);
        document.getElementById('review-summary-container').innerHTML = tableHtml;

        // Populate Review Client Info
        const cName = document.getElementById('client-name-input').value;
        const cAddr = document.getElementById('client-address-input').value;
        document.getElementById('review-client-info').innerHTML = `
            <strong>Bill To:</strong><br>
            ${cName}<br>
            ${cAddr}
        `;

        // Switch Views
        document.getElementById('order-form').classList.add('hidden');
        document.getElementById('review-view').classList.remove('hidden');
        window.scrollTo(0, 0);
    }

    function backToEdit() {
        document.getElementById('review-view').classList.add('hidden');
        document.getElementById('order-form').classList.remove('hidden');
        window.scrollTo(0, 0);
    }

    function confirmOrder() {
        // Disable UI
        const btn = document.getElementById('confirm-btn');
        btn.disabled = true;
        btn.textContent = "Submitting...";

        // Show Loading Overlay
        const loader = document.getElementById('loading');
        const loadText = document.getElementById('loading-text');
        if (loadText) loadText.textContent = "Processing Order...";
        loader.classList.remove('hidden');

        const payload = {
            clientId: CLIENT_ID,
            clientName: document.getElementById('client-name-input').value,
            clientAddress: document.getElementById('client-address-input').value,
            items: lastItems,
            totalPieces: document.getElementById('total-pieces').textContent
        };

        google.script.run
            .withSuccessHandler(onOrderSuccess)
            .withFailureHandler(onFailure)
            .processOrder(payload);
    }

    function generateOrderSummaryHtml(items) {
        let tableHtml = `<table style="width:100%; border-collapse: collapse; font-size:12px;">`;
        tableHtml += `<thead style="background:#f0f0f0; font-weight:bold;">
                        <tr>
                            <th style="padding:8px; border:1px solid #ddd;">Product</th>
                            <th style="padding:8px; border:1px solid #ddd;">Qty (Units)</th>
                            <th style="padding:8px; border:1px solid #ddd;">Line Total</th>
                        </tr>
                      </thead><tbody>`;

        let grandTotal = 0;

        // Enrich items with Product Details for display
        items.forEach(item => {
            const product = PRODUCT_CATALOG.find(p => p.sku === item.sku);
            if (product) {
                const name = product.name + (product.variation && product.variation !== "Standard" ? ` ${product.variation}` : "");

                // Calculate Price
                const price = Number(product.price) || 0;
                const salePrice = Number(product.salePrice) || 0;
                const catSetting = window.categorySettings && window.categorySettings[product.category];
                const catSaleActive = catSetting ? catSetting.saleActive : false;
                const isSale = catSaleActive && product.onSale && salePrice > 0;
                const finalPrice = isSale ? salePrice : price;

                const lineTotal = finalPrice * item.quantity;
                grandTotal += lineTotal;

                tableHtml += `<tr>
                                <td style="padding:8px; border:1px solid #ddd;">${name}</td>
                                <td style="padding:8px; border:1px solid #ddd; text-align:center;">${item.quantity}</td>
                                <td style="padding:8px; border:1px solid #ddd; text-align:right;">$${lineTotal.toFixed(2)}</td>
                              </tr>`;
            } else {
                tableHtml += `<tr>
                                <td style="padding:8px; border:1px solid #ddd;">${item.sku}</td>
                                <td style="padding:8px; border:1px solid #ddd; text-align:center;">${item.quantity}</td>
                                <td style="padding:8px; border:1px solid #ddd; text-align:right;">-</td>
                              </tr>`;
            }
        });

        tableHtml += `<tr style="font-weight:bold; background:#fafafa;">
                        <td colspan="2" style="padding:8px; border:1px solid #ddd; text-align:right;">Total:</td>
                        <td style="padding:8px; border:1px solid #ddd; text-align:right;">$${grandTotal.toFixed(2)}</td>
                      </tr>`;
        tableHtml += `</tbody></table>`;
        return tableHtml;
    }

    function onOrderSuccess(response) {
        document.getElementById('review-view').classList.add('hidden'); // Hide Review
        document.getElementById('order-form').classList.add('hidden'); // Ensure Form Hidden
        document.getElementById('success').classList.remove('hidden');
        document.getElementById('header-total').classList.add('hidden'); // Hide Subtotal
        document.getElementById('loading').classList.add('hidden'); // Hide Spinner

        // Use the same summary generation for success page or just clone it
        const summaryDiv = document.createElement('div');
        summaryDiv.style.marginTop = "20px";
        summaryDiv.style.textAlign = "left";

        summaryDiv.innerHTML = `<h3 class="md3-title-medium" style="margin-bottom:10px;">Order Summary</h3>` + generateOrderSummaryHtml(lastItems);

        const successEl = document.getElementById('success');
        successEl.appendChild(summaryDiv);
    }

    function onFailure(error) {
        showError("Error: " + error.message);
        const btn = document.getElementById('confirm-btn');
        if (btn) {
            btn.disabled = false;
            btn.textContent = "Confirm & Submit";
        }
        // Restore Review visibility
        document.getElementById('loading').classList.add('hidden');
    }

    function showError(msg) {
        document.getElementById('loading').classList.add('hidden');
        document.getElementById('error').classList.remove('hidden');
        document.getElementById('error-msg').textContent = msg;
    }
</script>

<script>
    /**
     * Setup IntersectionObserver to detect when Product Headers stick
     */
    function setupStickyObservers() {
        const summaries = document.querySelectorAll('.product-group-details > summary:not(.no-sticky)');
        window.removeEventListener('scroll', checkStickyHeaders);
        window.addEventListener('scroll', checkStickyHeaders);
        checkStickyHeaders(); // Initial check
    }

    function checkStickyHeaders() {
        const summaries = document.querySelectorAll('.product-group-details > summary:not(.no-sticky)');
        const STICKY_TOP = 60; // Top offset

        summaries.forEach(summary => {
            const rect = summary.getBoundingClientRect();
            if (rect.top <= STICKY_TOP + 1) {
                summary.classList.add('is-pinned');
            } else {
                summary.classList.remove('is-pinned');
            }
        });
    }

    /**
     * Group products by a "Base Name"
     */
    function groupProductsDynamically(products) {
        const groups = {};
        products.forEach(p => {
            // User requested NO stripping of numbers. Use exact name.
            let base = String(p.name).trim();
            if (!base) base = "Unknown";
            if (!groups[base]) groups[base] = [];
            groups[base].push(p);
        });
        return groups;
    }

    /**
     * Check if a group should be displayed as a 2D Matrix
     */
    function checkMatrixEligibility(products) {
        const byVar = {};
        products.forEach(p => {
            const v = p.variation || "Standard";
            if (!byVar[v]) byVar[v] = [];
            byVar[v].push(p);
        });

        // We only want Matrix layout if we have multiple NAMES (Columns) for the variations.
        // e.g. "Flavor X" comes in "100mg" and "200mg" (Different p.name).
        // If "Flavor X" comes in "Single" and "Case" (Same p.name, different Qty), 
        // that should NOT trigger Matrix, but go to Compact view to show side-by-side inputs.
        const hasMultipleCols = Object.values(byVar).some(arr => {
            const uniqueNames = new Set(arr.map(p => p.name));
            return uniqueNames.size > 1;
        });

        const hasMultipleVars = Object.keys(byVar).length > 1;
        return hasMultipleCols && hasMultipleVars;
    }
</script>