<script>
    /**
     * Global State
     */
    let PRODUCT_CATALOG = [];
    let CURRENT_CLIENT = null;

    /**
     * Initialize
     */
    window.onload = function () {
        if (!CLIENT_ID) {
            showError("No Client ID provided. Please use your valid link.");
            return;
        }

        // 1. Fetch Client Data
        google.script.run
            .withSuccessHandler(onClientDataSuccess)
            .withFailureHandler(onFailure)
            .getClientById(CLIENT_ID);
    };

    function onClientDataSuccess(client) {
        if (!client) {
            showError("Client not found in database.");
            return;
        }

        CURRENT_CLIENT = client;
        document.getElementById('client-name').textContent = client['Name'] || "Unknown Client";
        document.getElementById('client-details').textContent = client['Address'] || ""; // Or other fields

        // 2. Fetch Products
        google.script.run
            .withSuccessHandler(onProductsSuccess)
            .withFailureHandler(onFailure)
            .getProductCatalog();
    }

    function onProductsSuccess(products) {
        PRODUCT_CATALOG = products;
        renderProducts(products);

        document.getElementById('loading').classList.add('hidden');
        document.getElementById('order-form').classList.remove('hidden');
    }

    /**
     * Render Product List
     */
    function renderProducts(products) {
        const container = document.getElementById('product-list');
        container.innerHTML = "";

        // Group by Product Name? Or just list them? 
        // User wanted "Product Name" and "Version" logic.
        // We'll just render cards for each item for now, or group visually.

        products.forEach((p, index) => {
            const card = document.createElement('div');
            card.className = "md3-card";

            // Determine label
            const title = p.name + (p.variation ? ` - ${p.variation}` : "");
            const priceDisplay = p.price ? `$${p.price}` : "";

            card.innerHTML = `
      <div class="card-content">
        <h3 class="md3-title-large">${title}</h3>
        <p class="md3-body-medium">SKU: ${p.sku} | ${priceDisplay}</p>
        
        <div class="qty-input-group">
          <!-- Units Input -->
          <div class="md3-text-field">
            <label>Units</label>
            <input type="number" min="0" data-sku="${p.sku}" data-type="unit" class="qty-input" placeholder="0">
          </div>
          
          <!-- Case Input (if applicable) -->
          <!-- We treat this as a multiplier on backend or just separate KV? 
               Requirements said to inputs: "single unit or master case". 
               For the Order KV pair, we usually submit TOTAL pieces or separate SKUs?
               If "Case" is just x24 units of the SAME SKU, we multiply.
               If "Case" has a different SKU, we need that mapped. 
               
               Hypothesis from Plan: "PRODUCTS... Units/Case".
               We will convert Case Input -> Units * UnitsPerCase for the order?
               OR store as "SKU: 5 (Cases)"? 
               User said: "Table has fields ... # of Units, # of Cases".
               
               Let's simply capture both and calculate TOTAL UNITS for the final "SKU: QTY" text.
               Or if the user wants separate tracking, we need to know. 
               Given "Product N" columns with "SKU: QTY", usually means total units.
           -->
           ${p.unitsPerCase ? `
          <div class="md3-text-field">
            <label>Cases (x${p.unitsPerCase})</label>
            <input type="number" min="0" data-sku="${p.sku}" data-per-case="${p.unitsPerCase}" data-type="case" class="qty-input" placeholder="0">
          </div>
          ` : ''}
        </div>
      </div>
    `;
            container.appendChild(card);
        });

        // Attach Listeners
        const inputs = document.querySelectorAll('.qty-input');
        inputs.forEach(input => {
            input.addEventListener('input', calculateTotal);
        });
    }

    /**
     * Calculate Totals
     */
    function calculateTotal() {
        let totalPieces = 0;

        const inputs = document.querySelectorAll('.qty-input');
        inputs.forEach(input => {
            const val = parseInt(input.value) || 0;
            if (val > 0) {
                if (input.dataset.type === 'case') {
                    const perCase = parseInt(input.dataset.perCase) || 1;
                    totalPieces += (val * perCase);
                } else {
                    totalPieces += val;
                }
            }
        });

        document.getElementById('total-pieces').textContent = totalPieces;
    }

    /**
     * Submit Order
     */
    function submitOrder() {
        const inputs = document.querySelectorAll('.qty-input');
        const itemsMap = {}; // Map sku to total qty

        // Aggregate quantities by SKU
        inputs.forEach(input => {
            const val = parseInt(input.value) || 0;
            if (val > 0) {
                const sku = input.dataset.sku;
                if (!itemsMap[sku]) itemsMap[sku] = 0;

                if (input.dataset.type === 'case') {
                    const perCase = parseInt(input.dataset.perCase) || 1;
                    itemsMap[sku] += (val * perCase);
                } else {
                    itemsMap[sku] += val;
                }
            }
        });

        const items = Object.keys(itemsMap).map(sku => ({
            sku: sku,
            quantity: itemsMap[sku] // Total units
        }));

        if (items.length === 0) {
            alert("Please add at least one item.");
            return;
        }

        // Disable UI
        const btn = document.getElementById('submit-btn');
        btn.disabled = true;
        btn.textContent = "Submitting...";

        const payload = {
            clientId: CLIENT_ID,
            items: items,
            totalPieces: document.getElementById('total-pieces').textContent
        };

        google.script.run
            .withSuccessHandler(onOrderSuccess)
            .withFailureHandler(onFailure)
            .processOrder(payload);
    }

    function onOrderSuccess(response) {
        document.getElementById('order-form').classList.add('hidden');
        document.getElementById('success').classList.remove('hidden');
        // Optionally show PDF link if returned (it is!)
        if (response.pdfUrl) {
            const p = document.createElement('p');
            p.innerHTML = `<a href="${response.pdfUrl}" target="_blank">Download PDF Receipt</a>`;
            document.getElementById('success').appendChild(p);
        }
    }

    function onFailure(error) {
        showError("Error: " + error.message);
        const btn = document.getElementById('submit-btn');
        btn.disabled = false;
        btn.textContent = "Submit Order";
    }

    function showError(msg) {
        document.getElementById('loading').classList.add('hidden');
        document.getElementById('error').classList.remove('hidden');
        document.getElementById('error-msg').textContent = msg;
    }
</script>